// Minimal HashMap test

fn sizeof<T>() -> u64 { return 8; }
fn ptr_read<T>(ptr: u64) -> T { return ptr_read::<T>(ptr); }
fn ptr_write<T>(ptr: u64, val: T) { }
fn mem_alloc(size: u64) -> u64 { return 0; }
fn hash_i64(key: u64, seed: u64) -> u64 { return key; }

struct VecU64 {
    ptr: u64,
    len: u64,
    cap: u64,
}

fn vec_u64_new() -> VecU64 {
    return VecU64 { ptr: 0, len: 0, cap: 0 };
}

fn vec_u64_len(v: VecU64) -> u64 { return v.len; }

fn vec_u64_get(v: VecU64, index: u64) -> u64 {
    let offset = index * 8;
    return ptr_read::<u64>(v.ptr + offset);
}

fn vec_u64_set(v: VecU64, index: u64, val: u64) {
    let offset = index * 8;
    ptr_write::<u64>(v.ptr + offset, val);
}

fn vec_u64_push(v: VecU64, val: u64) -> VecU64 {
    // Simplified - no growth
    let offset = v.len * 8;
    if v.len == 0 {
        let new_ptr = mem_alloc(64);
        ptr_write::<u64>(new_ptr + offset, val);
        return VecU64 { ptr: new_ptr, len: 1, cap: 8 };
    }
    ptr_write::<u64>(v.ptr + offset, val);
    return VecU64 { ptr: v.ptr, len: v.len + 1, cap: v.cap };
}

contract HashMapTest {
    pub fn test_simple_insert() -> u64 {
        let keys = vec_u64_new();
        let vals = vec_u64_new();
        let occupied = vec_u64_new();
        
        // Initialize 4 slots
        keys = vec_u64_push(keys, 0);
        vals = vec_u64_push(vals, 0);
        occupied = vec_u64_push(occupied, 0);
        
        keys = vec_u64_push(keys, 0);
        vals = vec_u64_push(vals, 0);
        occupied = vec_u64_push(occupied, 0);
        
        // Insert one item
        let cap = vec_u64_len(keys);
        let key = 10;
        let val = 100;
        let h = hash_i64(key, 0);
        let idx = h - (h / cap) * cap;
        
        vec_u64_set(keys, idx, key);
        vec_u64_set(vals, idx, val);
        vec_u64_set(occupied, idx, 1);
        
        // Retrieve it
        let result = vec_u64_get(vals, idx);
        return result;
    }
}
