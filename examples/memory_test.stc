struct Point {
    x: u64,
    y: u64,
}

contract MemoryTest {
    pub fn check_overlap() -> u64 {
        let p1 = Point { x: 1, y: 2 };
        let p2 = Point { x: 3, y: 4 };
        
        if p1.x == 1 {
            return 1; // Success: p1 was not overwritten by p2
        }
        return 0; // Failure: p2 overwrote p1
    }

    pub fn check_different_addresses() -> u64 {
        let p1 = Point { x: 10, y: 20 };
        let p2 = Point { x: 30, y: 40 };
        
        // We can't easily return two values, but we can return p2 - p1
        // It should be 16 (size of Point)
        // Note: our current StructInit returns the pointer.
        // But we don't have a way to cast struct to u64 yet in the grammar?
        // Actually, 'let p1 = ...' infers Point, and 'p1' refers to the pointer.
        // Let's see if we can do math on pointers.
        // The grammar might not allow 'p2 - p1' if they are 'Point'.
        
        if p1.x == 10 {
            if p2.x == 30 {
                return 1;
            }
        }
        return 0;
    }
}
